//! Integration tests for BED format parsing.
//!
//! These tests validate BED3, BED6, and BED12 parsing with real-world
//! scenarios including headers, comments, and edge cases.

use biometal::formats::bed::{Bed12Record, Bed3Record, Bed6Record};
use biometal::formats::{Strand, TabDelimitedParser, TabDelimitedRecord};
use std::io::Cursor;

#[test]
fn test_bed3_basic_parsing() {
    let data = "\
chr1\t1000\t2000
chr2\t3000\t4000
chrX\t5000\t6000
";

    let parser = TabDelimitedParser::<_, Bed3Record>::new(Cursor::new(data.as_bytes()));
    let records: Vec<_> = parser.collect::<Result<_, _>>().unwrap();

    assert_eq!(records.len(), 3);
    assert_eq!(records[0].interval.chrom, "chr1");
    assert_eq!(records[0].interval.start, 1000);
    assert_eq!(records[0].interval.end, 2000);
    assert_eq!(records[2].interval.chrom, "chrX");
}

#[test]
fn test_bed3_with_comments() {
    let data = "\
# BED file header
# Generated by test
chr1\t1000\t2000
# Comment between records
chr2\t3000\t4000
";

    let parser = TabDelimitedParser::<_, Bed3Record>::new(Cursor::new(data.as_bytes()));
    let records: Vec<_> = parser.collect::<Result<_, _>>().unwrap();

    assert_eq!(records.len(), 2);
    assert_eq!(records[0].interval.chrom, "chr1");
    assert_eq!(records[1].interval.chrom, "chr2");
}

#[test]
fn test_bed3_interval_operations() {
    let r1 = Bed3Record::from_line("chr1\t1000\t2000").unwrap();
    let r2 = Bed3Record::from_line("chr1\t1500\t2500").unwrap();
    let r3 = Bed3Record::from_line("chr1\t3000\t4000").unwrap();

    // Overlapping intervals
    assert!(r1.interval.overlaps(&r2.interval));
    assert!(r2.interval.overlaps(&r1.interval)); // Symmetry

    // Non-overlapping intervals
    assert!(!r1.interval.overlaps(&r3.interval));
    assert!(!r3.interval.overlaps(&r1.interval));

    // Length
    assert_eq!(r1.interval.length(), 1000);
    assert_eq!(r2.interval.length(), 1000);
}

#[test]
fn test_bed6_all_fields() {
    let data = "\
chr1\t1000\t2000\tgene1\t500\t+
chr2\t3000\t4000\tgene2\t800\t-
chrX\t5000\t6000\tgeneX\t100\t.
";

    let parser = TabDelimitedParser::<_, Bed6Record>::new(Cursor::new(data.as_bytes()));
    let records: Vec<_> = parser.collect::<Result<_, _>>().unwrap();

    assert_eq!(records.len(), 3);

    // First record
    assert_eq!(records[0].bed3.interval.chrom, "chr1");
    assert_eq!(records[0].name, Some("gene1".to_string()));
    assert_eq!(records[0].score, Some(500));
    assert_eq!(records[0].strand, Some(Strand::Forward));

    // Second record
    assert_eq!(records[1].strand, Some(Strand::Reverse));

    // Third record
    assert_eq!(records[2].strand, Some(Strand::Unknown));
}

#[test]
fn test_bed6_missing_values() {
    let data = "\
chr1\t1000\t2000\t.\t.\t.
chr2\t3000\t4000\tgene2\t.\t+
chr3\t5000\t6000\t.\t500\t-
";

    let parser = TabDelimitedParser::<_, Bed6Record>::new(Cursor::new(data.as_bytes()));
    let records: Vec<_> = parser.collect::<Result<_, _>>().unwrap();

    // All missing
    assert_eq!(records[0].name, None);
    assert_eq!(records[0].score, None);
    assert_eq!(records[0].strand, Some(Strand::Unknown));

    // Name present, score missing
    assert_eq!(records[1].name, Some("gene2".to_string()));
    assert_eq!(records[1].score, None);
    assert_eq!(records[1].strand, Some(Strand::Forward));

    // Score present, name missing
    assert_eq!(records[2].name, None);
    assert_eq!(records[2].score, Some(500));
}

#[test]
fn test_bed6_round_trip() {
    let original_lines = vec![
        "chr1\t1000\t2000\tgene1\t500\t+",
        "chr2\t3000\t4000\t.\t.\t.",
        "chrX\t5000\t6000\tgeneX\t100\t-",
    ];

    for line in original_lines {
        let record = Bed6Record::from_line(line).unwrap();
        let output = record.to_line();
        assert_eq!(output, line);
    }
}

#[test]
fn test_bed12_full_parsing() {
    let line = "chr1\t1000\t5000\tTXN1\t100\t+\t1200\t4800\t0,0,255\t3\t400,600,400\t0,1000,4600";
    let record = Bed12Record::from_line(line).unwrap();

    assert_eq!(record.bed6.bed3.interval.chrom, "chr1");
    assert_eq!(record.bed6.bed3.interval.start, 1000);
    assert_eq!(record.bed6.bed3.interval.end, 5000);
    assert_eq!(record.bed6.name, Some("TXN1".to_string()));
    assert_eq!(record.bed6.score, Some(100));
    assert_eq!(record.bed6.strand, Some(Strand::Forward));

    assert_eq!(record.thick_start, Some(1200));
    assert_eq!(record.thick_end, Some(4800));
    assert_eq!(record.item_rgb, Some("0,0,255".to_string()));
    assert_eq!(record.block_count, Some(3));
    assert_eq!(record.block_sizes, Some(vec![400, 600, 400]));
    assert_eq!(record.block_starts, Some(vec![0, 1000, 4600]));
}

#[test]
fn test_bed12_minimal_fields() {
    let line = "chr1\t1000\t2000\tgene1\t100\t+\t.\t.\t.\t.\t.\t.";
    let record = Bed12Record::from_line(line).unwrap();

    // BED6 fields should be present
    assert_eq!(record.bed6.name, Some("gene1".to_string()));

    // BED12-specific fields should be None
    assert_eq!(record.thick_start, None);
    assert_eq!(record.thick_end, None);
    assert_eq!(record.item_rgb, None);
    assert_eq!(record.block_count, None);
    assert_eq!(record.block_sizes, None);
    assert_eq!(record.block_starts, None);
}

#[test]
fn test_bed12_single_exon_gene() {
    let line = "chr1\t1000\t2000\tgene1\t100\t+\t1100\t1900\t255,0,0\t1\t1000\t0";
    let record = Bed12Record::from_line(line).unwrap();

    assert_eq!(record.block_count, Some(1));
    assert_eq!(record.block_sizes, Some(vec![1000]));
    assert_eq!(record.block_starts, Some(vec![0]));

    // CDS should be within the exon
    assert!(record.thick_start.unwrap() >= record.bed6.bed3.interval.start);
    assert!(record.thick_end.unwrap() <= record.bed6.bed3.interval.end);
}

#[test]
fn test_bed12_multi_exon_gene() {
    let data = "\
chr1\t1000\t5000\tTXN1\t100\t+\t1200\t4800\t0,0,255\t3\t400,600,400\t0,1000,4600
chr2\t2000\t8000\tTXN2\t200\t-\t2500\t7500\t255,0,0\t2\t1000,2000\t0,4000
";

    let parser = TabDelimitedParser::<_, Bed12Record>::new(Cursor::new(data.as_bytes()));
    let records: Vec<_> = parser.collect::<Result<_, _>>().unwrap();

    assert_eq!(records.len(), 2);

    // First gene: 3 exons
    assert_eq!(records[0].block_count, Some(3));
    assert_eq!(records[0].block_sizes.as_ref().unwrap().len(), 3);
    assert_eq!(records[0].block_starts.as_ref().unwrap().len(), 3);

    // Second gene: 2 exons
    assert_eq!(records[1].block_count, Some(2));
    assert_eq!(records[1].block_sizes, Some(vec![1000, 2000]));
    assert_eq!(records[1].block_starts, Some(vec![0, 4000]));
}

#[test]
fn test_bed12_round_trip() {
    let original = "chr1\t1000\t5000\tTXN1\t100\t+\t1200\t4800\t0,0,255\t3\t400,600,400\t0,1000,4600";
    let record = Bed12Record::from_line(original).unwrap();
    let output = record.to_line();
    assert_eq!(output, original);
}

#[test]
fn test_bed_invalid_interval() {
    // start >= end should fail
    let result = Bed3Record::from_line("chr1\t2000\t1000");
    assert!(result.is_err());

    let result = Bed6Record::from_line("chr1\t2000\t2000\tgene1\t100\t+");
    assert!(result.is_err());
}

#[test]
fn test_bed_invalid_field_count() {
    // BED3 requires at least 3 fields
    let result = Bed3Record::from_line("chr1\t1000");
    assert!(result.is_err());

    // BED6 requires at least 6 fields
    let result = Bed6Record::from_line("chr1\t1000\t2000\tgene1\t100");
    assert!(result.is_err());

    // BED12 requires at least 12 fields
    let result = Bed12Record::from_line("chr1\t1000\t2000\tgene1\t100\t+\t1100\t1900");
    assert!(result.is_err());
}

#[test]
fn test_bed_invalid_strand() {
    // Invalid strand character
    let result = Bed6Record::from_line("chr1\t1000\t2000\tgene1\t100\tX");
    assert!(result.is_err());
}

#[test]
fn test_bed_realistic_gene_models() {
    // Simulated real gene annotations with multiple transcripts
    let data = "\
# UCSC-style BED12 gene annotations
chr7\t127471196\t127495720\tENST00000288602\t1000\t+\t127471196\t127495720\t0\t9\t894,152,105,109,178,76,1263,121,206\t0,10396,12474,13682,15161,16289,18146,22633,24318
chr7\t127472363\t127481458\tENST00000452263\t1000\t+\t127472363\t127481458\t0\t5\t152,105,109,178,76\t0,2078,3286,4765,5893
chr17\t7661779\t7687538\tENST00000357654\t1000\t-\t7661779\t7687538\t0\t11\t1189,105,118,219,243,171,246,152,107,86,2409\t0,2855,6244,7757,8942,13992,16150,19206,20646,22253,23350
";

    let parser = TabDelimitedParser::<_, Bed12Record>::new(Cursor::new(data.as_bytes()));
    let records: Vec<_> = parser.collect::<Result<_, _>>().unwrap();

    assert_eq!(records.len(), 3);

    // Validate first transcript
    assert_eq!(records[0].bed6.bed3.interval.chrom, "chr7");
    assert_eq!(records[0].bed6.name, Some("ENST00000288602".to_string()));
    assert_eq!(records[0].block_count, Some(9));
    assert_eq!(records[0].block_sizes.as_ref().unwrap().len(), 9);

    // Validate exon count matches block count
    for record in &records {
        if let Some(count) = record.block_count {
            assert_eq!(
                record.block_sizes.as_ref().unwrap().len(),
                count as usize
            );
            assert_eq!(
                record.block_starts.as_ref().unwrap().len(),
                count as usize
            );
        }
    }

    // Validate reverse strand transcript
    assert_eq!(records[2].bed6.strand, Some(Strand::Reverse));
    assert_eq!(records[2].block_count, Some(11));
}

#[test]
fn test_bed_empty_file() {
    let data = "\
# Empty BED file with only comments
# No data records
";

    let parser = TabDelimitedParser::<_, Bed3Record>::new(Cursor::new(data.as_bytes()));
    let records: Vec<_> = parser.collect::<Result<_, _>>().unwrap();

    assert_eq!(records.len(), 0);
}

#[test]
fn test_bed_different_chromosomes() {
    let data = "\
chr1\t1000\t2000\tgene1\t100\t+
chr2\t3000\t4000\tgene2\t200\t-
chrX\t5000\t6000\tgeneX\t300\t.
chrY\t7000\t8000\tgeneY\t400\t+
chrM\t9000\t10000\tgeneM\t500\t+
";

    let parser = TabDelimitedParser::<_, Bed6Record>::new(Cursor::new(data.as_bytes()));
    let records: Vec<_> = parser.collect::<Result<_, _>>().unwrap();

    assert_eq!(records.len(), 5);

    let chroms: Vec<_> = records.iter().map(|r| &r.bed3.interval.chrom).collect();
    assert_eq!(
        chroms,
        vec!["chr1", "chr2", "chrX", "chrY", "chrM"]
    );
}
