//! Integration tests for BCF reader with real bcftools-generated files.
//!
//! These tests validate that biometal can correctly parse BCF files generated
//! by bcftools, ensuring compatibility with the standard BCF format.

use biometal::io::bcf::{BcfReader, TypedValue};
use biometal::Result;
use std::path::PathBuf;

#[test]
fn test_bcf_basic_parsing() -> Result<()> {
    // Test file generated by: bcftools view -O b test_variants.vcf -o test_variants.bcf
    let test_file = PathBuf::from("tests/data/test_variants.bcf");

    let mut reader = BcfReader::from_path(&test_file)?;
    let header = reader.header();

    // Validate header
    assert_eq!(header.samples(), &["Sample1", "Sample2", "Sample3"]);
    assert_eq!(header.n_samples(), 3);
    assert_eq!(header.contigs(), &["chr1", "chr2", "chr3"]);

    // Validate FILTER dictionary
    assert_eq!(header.filter_index("PASS"), Some(0));
    assert_eq!(header.filter_index("LowQual"), Some(1));
    assert_eq!(header.filter_name(0), Some("PASS"));
    assert_eq!(header.filter_name(1), Some("LowQual"));

    // Validate INFO dictionary
    assert!(header.info_index("DP").is_some());
    assert!(header.info_index("AF").is_some());
    assert!(header.info_index("AC").is_some());

    // Validate FORMAT dictionary
    assert!(header.format_index("GT").is_some());
    assert!(header.format_index("GQ").is_some());
    assert!(header.format_index("DP").is_some());

    Ok(())
}

#[test]
fn test_bcf_record_parsing() -> Result<()> {
    let test_file = PathBuf::from("tests/data/test_variants.bcf");
    let mut reader = BcfReader::from_path(&test_file)?;

    let records: Vec<_> = reader.records().collect::<Result<Vec<_>>>()?;
    let header = reader.header();

    // Should have 5 records
    assert_eq!(records.len(), 5);

    // Test first record: chr1:100 A>T
    let rec = &records[0];
    assert_eq!(rec.chrom(header), "chr1");
    assert_eq!(rec.pos(), 100);  // 1-based
    assert_eq!(rec.reference(), "A");
    assert_eq!(rec.alternate(), &["T"]);
    assert_eq!(rec.id(), Some("rs001"));
    assert!(rec.is_pass());
    assert_eq!(rec.filter(header), vec!["PASS"]);

    // Check QUAL
    let qual = rec.qual().unwrap();
    assert!((qual - 30.5).abs() < 0.1);

    // Check INFO fields
    if let Some(dp) = rec.info("DP") {
        assert_eq!(dp.as_int(), Some(50));
    } else {
        panic!("Missing DP INFO field");
    }

    if let Some(af) = rec.info("AF") {
        assert_eq!(af.as_float(), Some(0.25));
    } else {
        panic!("Missing AF INFO field");
    }

    // Test second record: chr1:200 G>C,T (multi-allelic)
    let rec = &records[1];
    assert_eq!(rec.chrom(header), "chr1");
    assert_eq!(rec.pos(), 200);
    assert_eq!(rec.reference(), "G");
    assert_eq!(rec.alternate(), &["C", "T"]);
    assert_eq!(rec.id(), None);  // No ID (was '.')
    assert_eq!(rec.n_alleles(), 3);  // REF + 2 ALT

    // Check multi-allelic AF
    if let Some(af) = rec.info("AF") {
        if let TypedValue::FloatArray(values) = af {
            assert_eq!(values.len(), 2);
            assert!((values[0] - 0.3).abs() < 0.01);
            assert!((values[1] - 0.1).abs() < 0.01);
        } else {
            panic!("AF should be FloatArray for multi-allelic variant");
        }
    }

    // Test third record: chr2:500 with LowQual filter
    let rec = &records[2];
    assert_eq!(rec.chrom(header), "chr2");
    assert_eq!(rec.pos(), 500);
    assert_eq!(rec.id(), Some("rs002"));
    assert!(!rec.is_pass());
    assert_eq!(rec.filter(header), vec!["LowQual"]);

    // Test fifth record: chr3:2000 deletion (AT>A)
    let rec = &records[4];
    assert_eq!(rec.chrom(header), "chr3");
    assert_eq!(rec.pos(), 2000);
    assert_eq!(rec.reference(), "AT");
    assert_eq!(rec.alternate(), &["A"]);

    Ok(())
}

#[test]
fn test_bcf_genotype_data() -> Result<()> {
    let test_file = PathBuf::from("tests/data/test_variants.bcf");
    let mut reader = BcfReader::from_path(&test_file)?;

    let records: Vec<_> = reader.records().collect::<Result<Vec<_>>>()?;
    let _header = reader.header();

    // Test first record genotypes: chr1:100
    // Sample1: 0/1:40:20
    // Sample2: 0/0:50:25
    // Sample3: 0/1:35:15
    let rec = &records[0];

    // Check Sample1
    let sample1_gt = rec.format(0, "GT");
    assert!(sample1_gt.is_some(), "Sample1 should have GT field");

    let sample1_gq = rec.format(0, "GQ");
    if let Some(TypedValue::Int8(gq)) = sample1_gq {
        assert_eq!(*gq, 40);
    } else if let Some(TypedValue::Int16(gq)) = sample1_gq {
        assert_eq!(*gq, 40);
    } else {
        panic!("Sample1 GQ should be an integer");
    }

    let sample1_dp = rec.format(0, "DP");
    if let Some(TypedValue::Int8(dp)) = sample1_dp {
        assert_eq!(*dp, 20);
    } else if let Some(TypedValue::Int16(dp)) = sample1_dp {
        assert_eq!(*dp, 20);
    } else {
        panic!("Sample1 DP should be an integer");
    }

    // Check Sample2
    let sample2_gq = rec.format(1, "GQ");
    if let Some(TypedValue::Int8(gq)) = sample2_gq {
        assert_eq!(*gq, 50);
    } else if let Some(TypedValue::Int16(gq)) = sample2_gq {
        assert_eq!(*gq, 50);
    } else {
        panic!("Sample2 GQ should be an integer");
    }

    // Check that all samples have 3 FORMAT fields (GT, GQ, DP)
    for sample_idx in 0..3 {
        let genotype = rec.genotype(sample_idx).unwrap();
        assert_eq!(genotype.len(), 3, "Each sample should have 3 FORMAT fields");
    }

    Ok(())
}

#[test]
fn test_bcf_streaming_memory() -> Result<()> {
    // This test validates that we can iterate through records without loading them all
    let test_file = PathBuf::from("tests/data/test_variants.bcf");
    let mut reader = BcfReader::from_path(&test_file)?;

    let mut count = 0;
    for result in reader.records() {
        let _record = result?;
        count += 1;
    }

    assert_eq!(count, 5);
    Ok(())
}

#[test]
fn test_bcf_info_field_types() -> Result<()> {
    let test_file = PathBuf::from("tests/data/test_variants.bcf");
    let mut reader = BcfReader::from_path(&test_file)?;

    let records: Vec<_> = reader.records().collect::<Result<Vec<_>>>()?;
    let rec = &records[0];

    // DP should be integer
    if let Some(dp) = rec.info("DP") {
        assert!(dp.as_int().is_some(), "DP should be convertible to int");
    }

    // AF should be float
    if let Some(af) = rec.info("AF") {
        assert!(af.as_float().is_some(), "AF should be convertible to float");
    }

    // AC should be integer
    if let Some(ac) = rec.info("AC") {
        assert!(ac.as_int().is_some(), "AC should be convertible to int");
    }

    Ok(())
}
